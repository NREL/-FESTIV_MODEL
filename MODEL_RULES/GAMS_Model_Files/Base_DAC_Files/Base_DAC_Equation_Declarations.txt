=start
OBJECTIVE FUNCTION USED FOR MINIMIZATION
Q_LOAD_BALANCE(INTERVAL) EQUALS TOTAL GENERATION TO TOTAL LOAD  
Q_RESERVE_TOTAL(INTERVAL,RESERVETYPE) INCLUDE INCLUSIVE RESERVES
Q_RESERVE_BALANCE(INTERVAL,RESERVETYPE) TOTAL RESERVE SCHEDULES GREATER EQUAL TO REQUIREMENT
Q_RESERVE_BALANCE2(INTERVAL,RESERVETYPE) TOTAL RESERVE SCHEDULES EQUAL TO ZERO IF REQUIREMENT IS ZERO
Q_GENTOTAL(GEN,INTERVAL) TOTAL BLOCK GENERATION EQUALS SCHEDULE
Q_GEN_BLOCK_LIMIT1(GEN,BLOCK,INTERVAL) FOR BLOCK 1
Q_GEN_BLOCK_LIMIT2(GEN,BLOCK,INTERVAL) FOR OTHER BLOCKS
Q_GEN_BLOCK_LIMIT3(GEN,BLOCK,INTERVAL) FOR BLOCK 1 FOR PU VARIABLE CAPACITY
Q_GEN_BLOCK_LIMIT4(GEN,BLOCK,INTERVAL) FOR OTHER BLOCKS FOR PU VARIABLE CAPACITY
Q_GENLIMIT_HIGH(GEN,INTERVAL) CAPACITY CONSTRAINT
Q_GENLIMIT_HIGH2(GEN,INTERVAL) CAPACITY CONSTRAINT WITH RESERVES TOO
Q_RAMP_RATE_DOWN(GEN,INTERVAL) RAMP DOWN RATE MUST BE LESS THAN CAPABILITY
Q_RAMP_RATE_DOWN2(GEN,INTERVAL) RAMP DOWN RATE MUST BE LESS THAN CAPABILITY FOR INTERVAL 0
Q_VARIABLE_FORECAST(GEN,INTERVAL) WIND AND PV GENERATORS LIMIT BASED ON FORECASTS IS ADJUSTED EACH INTERVAL
Q_INTERFACE_SCHEDULE(GEN,INTERVAL) INTERFACE SCHEDULES EXACTLY AS SHOWN
Q_VARIABLE_RESERVE_CAPACITY(GEN,INTERVAL) IF WIND OR VG CAN PROVIDE RESERVES MUST BE BELOW FORECAST RATHER THAN NAMEPLATE
Q_PREDEFINED_INTERCHANGES DEFINE INTERCHANGE SCHEDULES
Q_PREDEFINED_INTERCHANGES2 INTERCHANGE SCHEDULES CANNOT PROVIDE RESERVES
Q_MIN_RUN_TIME(GEN,INTERVAL) MIN RUN TIME CONSTRAINT
Q_MIN_RUN_TIME2(GEN,INTERVAL) MIN RUN TIME FOR ENDING INTERVALS
Q_MIN_DOWN_TIME(GEN,INTERVAL) MIN DOWN TIME CONSTRAINT
Q_MIN_DOWN_TIME2(GEN,INTERVAL) MIN DOWN TIME CONSTRAINT FOR ENDING INTERVALS
Q_COMMITMENT_HARD_HI(GEN,INTERVAL) USED FOR DIFFERENT PURPOSES BUT ENFORCING COMMITMENT ON BY INTERVAL
Q_COMMITMENT_HARD_LO(GEN,INTERVAL) USED FOR DIFFERENT PURPOSES BUT ENFORCING COMMITMENT OFF BY INTERVAL
Q_MAX_START(GEN,INTERVAL) GEN CAN ONLY HAVE SO MANY STARTS PER DAY
Q_STARTUP(GEN,INTERVAL) TO DETERMINE STARTUP SHUTDOWN VARIABLES
Q_STARTUP2(GEN,INTERVAL) TO DETERMINE STARTUP SHUTDOWN VARIABLES FOR INTERVAL 0
Q_STARTUP3(GEN,INTERVAL) MAKE SURE CANNOT SU AND SD SIMULATANEOUSLY. COSTS WILL USUALLY DRIVE THESE DOWN IF THEY ARE NOT NECESSARY ANYWAY
Q_EARLY_SHUTDOWN1(GEN,INTERVAL) IN CASE A UNIT WANTS TO SHUTDOWN IN THE BEGINNING OF THE OPTIMIZATION
Q_RESERVE_CAPABILITY(GEN,INTERVAL,RESERVETYPE) FLEXIBLE RESERVE
Q_RESERVE_RAMPUP_LIMIT(GEN,INTERVAL) SHARING RAMP CAPABILITY BETWEEN RESERVE PRODUCTS
Q_RESERVE_RAMPDOWN_LIMIT (GEN,INTERVAL) SHARING RAMP CAPABILITY BETWEEN RESERVE PRODUCTS
Q_RESERVE_CAPABILITY_VG(GEN,INTERVAL,RESERVETYPE) FLEXIBLE RESERVE FOR VG
Q_HOURS_OFFLINE1(GEN,INTERVAL) EQUATIONS TO CALCULATE OFFLINE TIME AND TIE IT TO HOT WARM COLD STATUS
Q_HOURS_OFFLINE2(GEN,INTERVAL) EQUATIONS TO CALCULATE OFFLINE TIME AND TIE IT TO HOT WARM COLD STATUS
Q_HOURS_OFFLINE3(GEN,INTERVAL) EQUATIONS TO CALCULATE OFFLINE TIME AND TIE IT TO HOT WARM COLD STATUS
Q_HOURS_OFFLINE4(GEN,INTERVAL) EQUATIONS TO CALCULATE OFFLINE TIME AND TIE IT TO HOT WARM COLD STATUS
Q_HOURS_OFFLINE5(GEN,INTERVAL) EQUATIONS TO CALCULATE OFFLINE TIME AND TIE IT TO HOT WARM COLD STATUS
Q_HOURS_OFFLINE6(GEN,INTERVAL) EQUATIONS TO CALCULATE OFFLINE TIME AND TIE IT TO HOT WARM COLD STATUS
Q_HOURS_OFFLINE7(GEN,INTERVAL) EQUATIONS TO CALCULATE OFFLINE TIME AND TIE IT TO HOT WARM COLD STATUS
Q_HOURS_OFFLINE8(GEN,INTERVAL,STARTUP_TYPE) EQUATIONS TO CALCULATE OFFLINE TIME AND TIE IT TO HOT WARM COLD STATUS
Q_HOURS_OFFLINE9(GEN,INTERVAL,STARTUP_TYPE) EQUATIONS TO CALCULATE OFFLINE TIME AND TIE IT TO HOT WARM COLD STATUS
Q_VARIABLE_STARTUP1(GEN,INTERVAL) EQUATIONS FOR DETERMINING STARTUP COST
Q_VARIABLE_STARTUP2(GEN,INTERVAL) EQUATIONS FOR DETERMINING STARTUP COST
Q_VARIABLE_STARTUP3(GEN,INTERVAL) EQUATIONS FOR DETERMINING STARTUP COST
Q_VARIABLE_STARTUP4(GEN,INTERVAL) EQUATIONS FOR DETERMINING STARTUP COST
Q_VARIABLE_STARTUP5(GEN,INTERVAL) EQUATIONS FOR DETERMINING STARTUP COST
=end
=start
$IFI '%NETWORK_CHECK%' == YES Q_PHASE_SHIFTER1(BRANCH,INTERVAL) LOW LIMIT OF PHASE SHIFTER
$IFI '%NETWORK_CHECK%' == YES Q_PHASE_SHIFTER2(BRANCH,INTERVAL) HIGH LIMIT OF PHASE SHIFTER
$IFI '%NETWORK_CHECK%' == YES Q_PHASE_SHIFTER3(BRANCH,INTERVAL) ADDING BOTH TO SHOW NEGATIVE
$IFI '%NETWORK_CHECK%' == YES Q_PHASE_SHIFTER4(BRANCH,INTERVAL) 'FIXED PARS UPPER'
$IFI '%NETWORK_CHECK%' == YES Q_PHASE_SHIFTER5(BRANCH,INTERVAL) FIXED PARS LOWER
$IFI '%NETWORK_CHECK%' == YES Q_PHASE_SHIFTER(BUS,INTERVAL) TURNING PHASE SHIFTER TO ENERGY INJECTION
$IFI '%NETWORK_CHECK%' == YES Q_HVDC(BUS,INTERVAL) FROM BUS OF HVDC SAME AS SINK AND TO BUS SAME AS SOURCE
$IFI '%NETWORK_CHECK%' == YES Q_LOADFLOW_MISMATCH(BUS,INTERVAL) DC LOAD FLOW CALCULATION TO CALCULATE DELTA ANGLE
$IFI '%NETWORK_CHECK%' == YES Q_TRANSMISSIONFLOW(BRANCH,INTERVAL) DEFINES TRANSMISSION FLOWS BASED ON DELTA ANGLES AND BPRIME
$IFI '%NETWORK_CHECK%' == YES Q_SLACK_ANGLE(BUS,INTERVAL) DELTA ANGLE OF SLACK BUS EQUALS 0
$IFI '%NETWORK_CHECK%' == YES Q_NETENERGY(BUS,INTERVAL) NET ENERGY LEAVING A BUS   
$IFI '%NETWORK_CHECK%' == YES Q_TRANSMISSION_CONSTRAINT1(BRANCH,INTERVAL) TRANSMISSION LIMIT CONSTRAINT
$IFI '%NETWORK_CHECK%' == YES Q_TRANSMISSION_CONSTRAINT2(BRANCH,INTERVAL) TRANSMISSION LIMIT CONSTRAINT IN NEGATIVE DIRECTION
$IFI NOT '%SUSD_TRAJECTORY_CHECK%' == YES Q_GENLIMIT_LOW(GEN,INTERVAL) MIN GEN CONSTRAINT
$IFI NOT '%SUSD_TRAJECTORY_CHECK%' == YES Q_GENLIMIT_LOW2(GEN,INTERVAL) MIN GEN CONSTRAINT WITH REGULATION
$IFI '%SUSD_TRAJECTORY_CHECK%' == YES Q_SU_GENLIMITLOW_TRAJECTORY1(GEN,INTERVAL)
$IFI '%SUSD_TRAJECTORY_CHECK%' == YES Q_SU_GENLIMITLOW_TRAJECTORY2(GEN,INTERVAL)
$IFI '%SUSD_TRAJECTORY_CHECK%' == YES Q_SU_GENLIMITLOW_TRAJECTORY3(GEN,INTERVAL)
$IFI NOT '%SUSD_TRAJECTORY_CHECK%' == YES Q_RAMP_RATE_UP(GEN,INTERVAL) RAMP UP RATE MUST BE LESS THAN CAPABILITY
$IFI NOT '%SUSD_TRAJECTORY_CHECK%' == YES Q_RAMP_RATE_UP2(GEN,INTERVAL) RAMP UP RATE MUST BE LESS THAN CAPABILITY FOR INTERVAL 0
$IFI '%SUSD_TRAJECTORY_CHECK%' == YES Q_SU_RAMPUP_TRAJECTORY1(GEN,INTERVAL)
$IFI '%SUSD_TRAJECTORY_CHECK%' == YES Q_SU_RAMPUP_TRAJECTORY2(GEN,INTERVAL)
$IFI '%SUSD_TRAJECTORY_CHECK%' == YES Q_SU_RAMPUP_TRAJECTORY0(GEN,INTERVAL)
$IFI '%SUSD_TRAJECTORY_CHECK%' == YES Q_SU_RESERVE_TRAJECTORY1(GEN,INTERVAL,RESERVETYPE)
$IFI '%SUSD_TRAJECTORY_CHECK%' == YES Q_SU_RESERVE_TRAJECTORY2(GEN,INTERVAL,RESERVETYPE)
$IFI '%SUSD_TRAJECTORY_CHECK%' == YES Q_SU_RESERVE_TRAJECTORY3(GEN,INTERVAL,RESERVETYPE)
$IFI '%SUSD_TRAJECTORY_CHECK%' == YES Q_SU_RAMPDOWN_TRAJECTORY1(GEN,INTERVAL)
$IFI '%SUSD_TRAJECTORY_CHECK%' == YES Q_SU_RAMPDOWN_TRAJECTORY2(GEN,INTERVAL)
$IFI '%CONTINGENCY_CHECK%' == YES Q_TRANSMISSIONFLOW_CTGC(BRANCH,BRANCH2,INTERVAL) DEFINES TRANSMISSION FLOWS FOLLOWING CONTINGENCY BASED ON DELTA ANGLES AND BPRIME
$IFI '%CONTINGENCY_CHECK%' == YES Q_TRANSMISSIONFLOW_CTGC2(BRANCH,BRANCH2,INTERVAL) FLOW OF TRIPPED TX IS 0
$IFI '%CONTINGENCY_CHECK%' == YES Q_LOADFLOW_MISMATCH_CTGC(BRANCH,BUS,INTERVAL) DC LOAD FLOW CALCULATION TO CALCULATE DELTA ANGLE FOLLOWING CONTINGENCY
$IFI '%CONTINGENCY_CHECK%' == YES Q_PAR_CTGC(BRANCH,BRANCH,INTERVAL) ANGLE OF PAR THAT IS OUT IS 0
$IFI '%CONTINGENCY_CHECK%' == YES Q_PAR_CTGC2(BRANCH,BRANCH,INTERVAL) ANGLE OF PAR THAT IS NOT OUT IS SAME AS PRECTGC
$IFI '%CONTINGENCY_CHECK%' == YES Q_HVDC_CTGC(BRANCH,BUS,INTERVAL) IF HVDC FAILS ADJUST BUS OUTPUTS
$IFI '%CONTINGENCY_CHECK%' == YES Q_TRANSMISSION_CONSTRAINT1_CTGC(BRANCH,BRANCH2,INTERVAL) EMERGENCY TRANSMISSION LIMIT CONSTRAINT FOLLOWING CONTINGENCY
$IFI '%CONTINGENCY_CHECK%' == YES Q_TRANSMISSION_CONSTRAINT2_CTGC(BRANCH,BRANCH2,INTERVAL) EMERGENCY TRANSMISSION LIMIT CONSTRAINT IN OTHER DIRECTION FOLLOWING CONTINGENCY
$IFI '%CONTINGENCY_CHECK%' == YES Q_SLACK_ANGLE_CTGC(BRANCH,BUS,INTERVAL) DELTA ANGLE OF SLACK BUS EQUALS 0 FOLLOWING CONTINGENCY
=end